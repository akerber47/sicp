; 3.24
(define (make-table-comp same-key?)
  (let ((table (list '*table*)))
    (define (lookup key)
      (let ((record (assq key (cdr table))))
           (if (null? record)
               '()
               (cdr record))))
    (define (assq key records)
      (cond ((null? records) '())
            ((same-key? key (caar records)) (car records))
            (else (assq key (cdr records)))))
    (define (insert! key value)
      (let ((record (assq key (cdr table))))
        (if (null? record)
            (set-cdr! table (cons (cons key value) (cdr table)))
            (set-cdr! record value)))
      'ok)
    (define (me m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "Unknown operation!" m))))
    me))

; 3.25
; support code
(define (make-table) (cons '*table* '()))
(define (assq key records)
  (cond ((null? records) '())
        ((eq? key (caar records)) (car records))
        (else (assq key (cdr records)))))

(define (lookup key-list table)
  (if (null? key-list)
      (error "Empty key list for lookup!")
      (let ((record (assq (car key-list) (cdr table))))
        (if (null? record)
            '()
            (if (null? (cdr key-list))
                (cdr record)
                (lookup (cdr key-list) (cdr record)))))))

(define (insert! key-list value table)
  (if (null? key-list)
      (error "Empty key list for insertion!")
      (let ((record (assq (car key-list) (cdr table))))
        (if (null? (cdr key-list))
            (if (null? record)
                (set-cdr! table
                          (cons (cons (car key-list) value) (cdr table)))
                (set-cdr! record value))
            (if (null? record)
                (let ((subt (make-table)))
                  (insert! (cdr key-list) value subt)
                  (set-cdr! table
                            (cons (cons (car key-list) subt) (cdr table))))
                (insert! (cdr key-list) value (cdr record)))))))

; 3.26
(define (node-key tree) (car tree))
(define (node-val tree) (cadr tree))
(define (node-left tree) (caddr tree))
(define (node-right tree) (cadddr tree))
(define (node-set-val! tree v) (set-car! (cdr tree) v))
(define (node-set-left! tree v) (set-car! (cddr tree) v))
(define (node-set-right! tree v) (set-car! (cdddr tree) v))

(define (make-tree key val left right)
  (list key val left right))

(define (make-tree-table)
  (cons '*table* '()))

(define (tree-lookup key table)
  (define (tree-lookup-rec key tree)
    (cond
      ((null? tree) '())
      ((= key (node-key tree)) (node-val tree))
      ((< key (node-key tree))
       (tree-lookup-rec key (node-left tree)))
      (else
        (tree-lookup-rec key (node-right tree)))))
  (tree-lookup-rec key (cdr table)))

(define (tree-insert! key val table)
  (define (tree-insert!-rec key val tree)
    (cond
      ((= key (node-key tree)) (node-set-val! tree val))
      ((< key (node-key tree))
       (if (null? (node-left tree))
           (node-set-left! tree (make-tree key val '() '()))
           (tree-insert!-rec key val (node-left tree))))
      (else
       (if (null? (node-right tree))
           (node-set-right! tree (make-tree key val '() '()))
           (tree-insert!-rec key val (node-right tree))))))
  (if (null? (cdr table))
      (set-cdr! table (make-tree key val '() '()))
      (tree-insert!-rec key val (cdr table))))
